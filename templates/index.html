{% extends "base.html" %}

{% block title %}Riftbound Card Scanner{% endblock %}

{% block content %}
  <h1>Riftbound Card Scanner</h1>
  <div class="meta">
    {{ card_count }} cards indexed · {{ image_count }} images loaded
  </div>

  <div class="layout">
    <div class="panel">
      <h2>Upload Photo</h2>
      <input id="photoInput" type="file" accept="image/*" hidden />
      <button id="selectPhoto">Select Photo</button>
      <div class="camera-block">
        <h2>Scan with Camera</h2>
        <div id="cameraContainer" style="position: relative; width: 100%; max-width: 640px; border-radius: 12px; overflow: hidden; aspect-ratio: 16/9; background: #000;">
          <video id="cameraPreview" autoplay playsinline muted style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; background: none;"></video>
          <canvas id="cameraOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; background: none !important;"></canvas>
        </div>
        <canvas id="cameraCanvas" hidden></canvas>
        <div class="camera-actions">
          <button id="startCamera" class="secondary" type="button">Start camera</button>
          <button id="autoScan" class="secondary" type="button" disabled>Auto scan</button>
          <button id="stopCamera" class="secondary" type="button" disabled>Stop</button>
        </div>
      </div>
      <div id="status" class="result">Select a photo to start.</div>
      <div class="pending-matches">
        <div class="pending-header-row">
          <div style="display: flex; align-items: baseline; gap: 10px; flex-wrap: wrap;">
            <strong>Pending matches</strong>
            <span id="pendingCountMeta" class="meta" style="margin: 0;"></span>
          </div>
          <div class="pending-bulk-actions">
            <button id="pendingDeleteAll" class="secondary" type="button">Delete all</button>
            <button id="pendingSaveAll" type="button">Save all</button>
          </div>
        </div>
        <div id="pendingEmpty" class="empty-state">No pending matches yet.</div>
        <div id="pendingGrid" class="saved-grid pending-grid"></div>
      </div>
    </div>
  </div>

  <!-- Confirmation Modal -->
  <div id="confirmModal" class="modal-backdrop" style="display: none;">
    <div class="modal" role="dialog" aria-modal="true">
      <img id="modalImage" class="modal-preview" alt="Matched card" style="max-width: 200px; border-radius: 8px;" />
      <h3 id="modalTitle">Card Detected</h3>
      <p id="modalMeta" style="color: #94a3b8;"></p>
      <div class="modal-actions">
        <button id="btnConfirmYes" type="button">Yes, Add It</button>
        <button id="btnConfirmNo" class="secondary" type="button">No, Skip</button>
      </div>
    </div>
  </div>

  <script>
    const photoInput = document.getElementById("photoInput");
    const statusBox = document.getElementById("status");
    const selectButton = document.getElementById("selectPhoto");
    const cameraPreview = document.getElementById("cameraPreview");
    const cameraCanvas = document.getElementById("cameraCanvas");
    const cameraOverlay = document.getElementById("cameraOverlay");
    const overlayCtx = cameraOverlay.getContext("2d", { alpha: true });
    const startCameraButton = document.getElementById("startCamera");
    const autoScanButton = document.getElementById("autoScan");
    const stopCameraButton = document.getElementById("stopCamera");
    const pendingGrid = document.getElementById("pendingGrid");
    const pendingEmpty = document.getElementById("pendingEmpty");
    const pendingCountMeta = document.getElementById("pendingCountMeta");
    const pendingSaveAll = document.getElementById("pendingSaveAll");
    const pendingDeleteAll = document.getElementById("pendingDeleteAll");
    
    // Modal elements
    const confirmModal = document.getElementById("confirmModal");
    const modalImage = document.getElementById("modalImage");
    const modalTitle = document.getElementById("modalTitle");
    const modalMeta = document.getElementById("modalMeta");
    const btnConfirmYes = document.getElementById("btnConfirmYes");
    const btnConfirmNo = document.getElementById("btnConfirmNo");
    
    const storageKey = "riftbound_saved_cards";
    const savedCards = new Map();
    const pendingStorageKey = "riftbound_pending_cards";
    const pendingCards = new Map();
    let selectedDataUrl = null;
    let serverUser = null;
    let cameraStream = null;
    let autoScanTimer = null;
    let isScanning = false;
    let currentMatch = null;
    let lastMatchId = null;
    let matchStability = 0;
    
    // Auto-scan settings
    const SCAN_INTERVAL = 400;
    const MATCH_THRESHOLD = 28;
    const STABILITY_REQUIRED = 2;
    const ROI_SCALE = 0.7;

    function setStatus(message, isError = false) {
      if (isError) {
        statusBox.innerHTML = `<span class="error">${message}</span>`;
      } else {
        statusBox.textContent = message;
      }
    }

    function readSavedCards() {
      const raw = localStorage.getItem(storageKey);
      if (!raw) {
        return [];
      }
      try {
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (error) {
        return [];
      }
    }

    function readPendingCards() {
      const raw = localStorage.getItem(pendingStorageKey);
      if (!raw) {
        return [];
      }
      try {
        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : [];
      } catch (error) {
        return [];
      }
    }

    function persistSavedCards() {
      const payload = Array.from(savedCards.values());
      localStorage.setItem(storageKey, JSON.stringify(payload));
    }

    function persistPendingCards() {
      const payload = Array.from(pendingCards.values());
      localStorage.setItem(pendingStorageKey, JSON.stringify(payload));
    }

    function writeSavedCards(cards) {
      const payload = Array.isArray(cards) ? cards : [];
      localStorage.setItem(storageKey, JSON.stringify(payload));
    }

    function writePendingCards(cards) {
      const payload = Array.isArray(cards) ? cards : [];
      localStorage.setItem(pendingStorageKey, JSON.stringify(payload));
    }

    function mergeCollections(localCards, remoteCards) {
      const merged = new Map();
      (remoteCards || []).forEach((card) => {
        if (!card || !card.key) return;
        merged.set(card.key, { ...card });
      });
      (localCards || []).forEach((card) => {
        if (!card || !card.key) return;
        const existing = merged.get(card.key);
        if (!existing) {
          merged.set(card.key, { ...card });
          return;
        }
        const localCount = Number(card.count) || 1;
        const remoteCount = Number(existing.count) || 1;
        merged.set(card.key, {
          ...existing,
          ...card,
          count: Math.max(localCount, remoteCount),
        });
      });
      return Array.from(merged.values());
    }

    function updatePendingEmptyState() {
      pendingEmpty.style.display = pendingCards.size ? "none" : "block";
    }

    function updatePendingCounts() {
      const uniqueCount = pendingCards.size;
      let totalCount = 0;
      pendingCards.forEach((card) => {
        totalCount += Number(card?.count) || 0;
      });
      if (pendingCountMeta) {
        pendingCountMeta.textContent = uniqueCount
          ? `${uniqueCount} unique · ${totalCount} total`
          : "0 pending";
      }
    }

    function renderPendingCard(cardData) {
      const card = document.createElement("div");
      card.className = "saved-card pending-card";
      card.dataset.cardKey = cardData.key;
      const img = document.createElement("img");
      img.src = cardData.image_url;
      img.alt = cardData.name || "Pending match";
      const count = document.createElement("div");
      count.className = "saved-count";
      count.textContent = String(cardData.count || 1);
      const label = document.createElement("div");
      label.textContent = cardData.name || "Pending match";
      const actions = document.createElement("div");
      actions.className = "saved-actions";
      actions.innerHTML = `
        <button class="secondary" type="button" data-action="delete">Delete</button>
        <button class="increment" type="button" data-action="save">Save</button>
      `;
      card.appendChild(count);
      card.appendChild(img);
      card.appendChild(label);
      card.appendChild(actions);
      pendingGrid.prepend(card);
    }

    function hydrateSavedCards() {
      const items = readSavedCards();
      items.forEach((item) => {
        if (!item || !item.key) return;
        savedCards.set(item.key, item);
      });
    }

    function hydratePendingCards() {
      const items = readPendingCards();
      items.forEach((item) => {
        if (!item || !item.key) return;
        pendingCards.set(item.key, item);
        renderPendingCard(item);
      });
      updatePendingEmptyState();
      updatePendingCounts();
    }

    function addToPending(payload) {
      const key = payload.riftbound_id || payload.name || payload.image_url;
      const name = payload.name || payload.riftbound_id || "Matched card";
      const imageUrl = payload.image_url;
      const existing = pendingCards.get(key);
      if (existing) {
        existing.count = (Number(existing.count) || 1) + 1;
        const card = pendingGrid.querySelector(
          `[data-card-key="${CSS.escape(key)}"]`
        );
        const countEl = card?.querySelector(".saved-count");
        if (countEl) {
          countEl.textContent = String(existing.count);
        }
      } else {
        const cardData = {
          key,
          name,
          image_url: imageUrl,
          count: 1,
        };
        pendingCards.set(key, cardData);
        renderPendingCard(cardData);
      }
      persistPendingCards();
      updatePendingEmptyState();
      updatePendingCounts();
    }

    function movePendingToSaved(cardData) {
      const key = cardData.key;
      const existing = savedCards.get(key);
      if (existing) {
        existing.count = (Number(existing.count) || 1) + (Number(cardData.count) || 1);
      } else {
        const nextCard = {
          key,
          name: cardData.name,
          image_url: cardData.image_url,
          count: Number(cardData.count) || 1,
        };
        savedCards.set(key, nextCard);
      }
      persistSavedCards();
      saveServerCollection(Array.from(savedCards.values()));
    }

    async function loadServerUser() {
      try {
        const res = await fetch("/auth/me", { method: "GET" });
        const data = await res.json();
        return data.user || null;
      } catch (error) {
        return null;
      }
    }

    async function fetchServerCollection() {
      if (!serverUser) return [];
      try {
        const res = await fetch("/collection", { method: "GET" });
        const data = await res.json();
        const cards = Array.isArray(data.cards) ? data.cards : [];
        return cards.map((card) => ({
          key: card.card_key || card.key,
          name: card.name,
          image_url: card.image_url,
          count: card.count,
        }));
      } catch (error) {
        return [];
      }
    }

    async function saveServerCollection(cards) {
      if (!serverUser) return;
      try {
        await fetch("/collection", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ cards }),
        });
      } catch (error) {
        // ignore network sync errors
      }
    }

    async function syncCollectionFromServer() {
      if (!serverUser) return;
      const localCards = readSavedCards();
      const remoteCards = await fetchServerCollection();
      if (!remoteCards.length && localCards.length) {
        await saveServerCollection(localCards);
        return;
      }
      if (remoteCards.length) {
        const merged = mergeCollections(localCards, remoteCards);
        writeSavedCards(merged);
        await saveServerCollection(merged);
      }
    }

    // ROI calculation
    function getROI() {
      const vw = cameraPreview.videoWidth || 640;
      const vh = cameraPreview.videoHeight || 480;
      const roiH = Math.round(vh * ROI_SCALE);
      const roiW = Math.round(roiH / 1.4);
      const x = Math.round((vw - roiW) / 2);
      const y = Math.round((vh - roiH) / 2);
      return { x, y, w: roiW, h: roiH, vw, vh };
    }

    // Draw ROI overlay
    function drawOverlay(hasMatch = false) {
      const { x, y, w, h, vw, vh } = getROI();
      
      cameraOverlay.width = vw;
      cameraOverlay.height = vh;
      overlayCtx.clearRect(0, 0, vw, vh);
      
      const color = hasMatch ? "#22c55e" : "#6366f1";
      
      // Draw ROI rectangle
      overlayCtx.strokeStyle = color;
      overlayCtx.lineWidth = 3;
      overlayCtx.strokeRect(x, y, w, h);
      
      // Corner markers
      const c = 25;
      overlayCtx.lineWidth = 5;
      // Top-left
      overlayCtx.beginPath();
      overlayCtx.moveTo(x, y + c); overlayCtx.lineTo(x, y); overlayCtx.lineTo(x + c, y);
      overlayCtx.stroke();
      // Top-right
      overlayCtx.beginPath();
      overlayCtx.moveTo(x + w - c, y); overlayCtx.lineTo(x + w, y); overlayCtx.lineTo(x + w, y + c);
      overlayCtx.stroke();
      // Bottom-left
      overlayCtx.beginPath();
      overlayCtx.moveTo(x, y + h - c); overlayCtx.lineTo(x, y + h); overlayCtx.lineTo(x + c, y + h);
      overlayCtx.stroke();
      // Bottom-right
      overlayCtx.beginPath();
      overlayCtx.moveTo(x + w - c, y + h); overlayCtx.lineTo(x + w, y + h); overlayCtx.lineTo(x + w, y + h - c);
      overlayCtx.stroke();
      
      // Instruction text
      if (!hasMatch && isScanning) {
        overlayCtx.font = "16px system-ui, sans-serif";
        overlayCtx.fillStyle = color;
        overlayCtx.textAlign = "center";
        overlayCtx.fillText("Hold card in frame", vw / 2, y + h + 30);
      }
    }

    // Capture ROI region only
    function captureROI() {
      const { x, y, w, h } = getROI();
      cameraCanvas.width = w;
      cameraCanvas.height = h;
      const ctx = cameraCanvas.getContext("2d");
      ctx.drawImage(cameraPreview, x, y, w, h, 0, 0, w, h);
      return cameraCanvas.toDataURL("image/jpeg", 0.85);
    }

    // Modal functions
    function showConfirmModal(match) {
      stopAutoScanLoop();
      currentMatch = match;
      modalImage.src = match.image_url;
      modalTitle.textContent = match.name;
      modalMeta.textContent = `Distance: ${match.distance}`;
      confirmModal.style.display = "flex";
    }

    function closeConfirmModal() {
      confirmModal.style.display = "none";
      currentMatch = null;
      lastMatchId = null;
      matchStability = 0;
      if (cameraStream && isScanning) {
        startAutoScanLoop();
      }
    }

    function confirmMatch() {
      if (currentMatch) {
        addToPending(currentMatch);
        setStatus(`Added "${currentMatch.name}" to pending.`);
      }
      closeConfirmModal();
    }

    function skipMatch() {
      setStatus("Skipped. Continue scanning.");
      closeConfirmModal();
    }

    // Fast match using ROI
    async function fastMatchROI() {
      if (!cameraStream || confirmModal.style.display !== "none") return;
      
      const imageData = captureROI();
      
      try {
        const resp = await fetch("/api/fast-match", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ image: imageData, threshold: MATCH_THRESHOLD }),
        });
        const data = await resp.json();
        
        if (data.matched) {
          // Check stability
          if (data.riftbound_id === lastMatchId) {
            matchStability++;
          } else {
            lastMatchId = data.riftbound_id;
            matchStability = 1;
          }
          
          drawOverlay(true);
          
          if (matchStability >= STABILITY_REQUIRED) {
            showConfirmModal(data);
          } else {
            setStatus(`Hold steady... (${matchStability}/${STABILITY_REQUIRED})`);
          }
        } else {
          lastMatchId = null;
          matchStability = 0;
          drawOverlay(false);
          setStatus("Scanning... hold card in frame.");
        }
      } catch (err) {
        console.error("Fast match error:", err);
      }
    }

    // Legacy match using full frame (for manual capture/photo upload)
    async function matchPhoto() {
      if (!selectedDataUrl) {
        setStatus("Select a photo first.", true);
        return;
      }
      setStatus("Matching...");

      const response = await fetch("/match", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ image: selectedDataUrl }),
      });

      const payload = await response.json();
      if (!response.ok) {
        setStatus(payload.error || "Match failed", true);
        return;
      }

      setStatus("Match added to pending list.");
      if (payload.image_url) {
        addToPending(payload);
      }
    }

    function deletePendingCard(card, key) {
      pendingCards.delete(key);
      card.remove();
      persistPendingCards();
      updatePendingEmptyState();
      updatePendingCounts();
    }

    photoInput.addEventListener("change", (event) => {
      const file = event.target.files[0];
      if (!file) {
        selectedDataUrl = null;
        setStatus("Select a photo to start.");
        return;
      }
      const reader = new FileReader();
      reader.onload = () => {
        selectedDataUrl = reader.result;
        setStatus("Matching...");
        matchPhoto();
      };
      reader.readAsDataURL(file);
      event.target.value = "";
    });

    selectButton.addEventListener("click", () => {
      photoInput.value = "";
      photoInput.click();
    });

    async function startCamera() {
      if (!navigator.mediaDevices?.getUserMedia) {
        setStatus("Camera not supported in this browser.", true);
        return;
      }
      try {
        setStatus("Requesting camera access...");
        cameraStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false,
        });
        
        cameraPreview.srcObject = cameraStream;
        
        // Wait for video metadata to load
        await new Promise((resolve, reject) => {
          cameraPreview.onloadedmetadata = () => {
            console.log("Video dimensions:", cameraPreview.videoWidth, "x", cameraPreview.videoHeight);
            resolve();
          };
          cameraPreview.onerror = (e) => reject(e);
          setTimeout(() => resolve(), 3000); // Fallback timeout
        });
        
        // Explicitly play
        try {
          await cameraPreview.play();
          console.log("Video playing, readyState:", cameraPreview.readyState);
        } catch (playError) {
          console.warn("Autoplay blocked, user interaction may be needed:", playError);
        }
        
        // Check if video is actually rendering
        if (cameraPreview.videoWidth === 0 || cameraPreview.videoHeight === 0) {
          console.warn("Video dimensions are 0, stream may not be working");
        }
        
        autoScanButton.disabled = false;
        stopCameraButton.disabled = false;
        startCameraButton.disabled = true;
        setStatus("Camera ready. Tap capture or enable auto scan.");
        
        // Draw overlay after a short delay to ensure video is rendering
        setTimeout(() => drawOverlay(false), 100);
      } catch (error) {
        console.error("Camera error:", error);
        setStatus("Camera permission denied or unavailable.", true);
      }
    }

    function stopCamera() {
      stopAutoScan();
      if (cameraStream) {
        cameraStream.getTracks().forEach((track) => track.stop());
        cameraStream = null;
      }
      cameraPreview.srcObject = null;
      overlayCtx.clearRect(0, 0, cameraOverlay.width, cameraOverlay.height);
      autoScanButton.disabled = true;
      stopCameraButton.disabled = true;
      startCameraButton.disabled = false;
      setStatus("Camera stopped.");
    }

    function startAutoScanLoop() {
      if (autoScanTimer) return;
      autoScanTimer = setInterval(fastMatchROI, SCAN_INTERVAL);
    }

    function stopAutoScanLoop() {
      if (autoScanTimer) {
        clearInterval(autoScanTimer);
        autoScanTimer = null;
      }
    }

    function startAutoScan() {
      if (!cameraStream) return;
      isScanning = true;
      autoScanButton.textContent = "Stop auto";
      autoScanButton.classList.remove("secondary");
      setStatus("Auto scanning... hold card in frame.");
      drawOverlay(false);
      startAutoScanLoop();
    }

    function stopAutoScan() {
      isScanning = false;
      autoScanButton.textContent = "Auto scan";
      autoScanButton.classList.add("secondary");
      stopAutoScanLoop();
      lastMatchId = null;
      matchStability = 0;
      overlayCtx.clearRect(0, 0, cameraOverlay.width, cameraOverlay.height);
      setStatus("Auto scan stopped.");
    }

    function toggleAutoScan() {
      if (isScanning) {
        stopAutoScan();
      } else {
        startAutoScan();
      }
    }

    startCameraButton.addEventListener("click", startCamera);
    stopCameraButton.addEventListener("click", stopCamera);
    autoScanButton.addEventListener("click", toggleAutoScan);

    // Modal event listeners
    btnConfirmYes.addEventListener("click", confirmMatch);
    btnConfirmNo.addEventListener("click", skipMatch);
    confirmModal.addEventListener("click", (e) => {
      if (e.target === confirmModal) skipMatch();
    });
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && confirmModal.style.display !== "none") {
        skipMatch();
      }
    });

    pendingGrid.addEventListener("click", (event) => {
      const button = event.target.closest("button[data-action]");
      if (!button) return;
      const card = button.closest(".pending-card");
      if (!card) return;
      const key = card.dataset.cardKey;
      const cardData = pendingCards.get(key);
      if (!cardData) return;
      const action = button.dataset.action;
      if (action === "delete") {
        deletePendingCard(card, key);
        return;
      }
      if (action === "save") {
        movePendingToSaved(cardData);
        deletePendingCard(card, key);
      }
    });

    pendingSaveAll.addEventListener("click", () => {
      if (!pendingCards.size) return;
      Array.from(pendingCards.values()).forEach((cardData) => {
        movePendingToSaved(cardData);
      });
      pendingCards.clear();
      pendingGrid.innerHTML = "";
      persistPendingCards();
      updatePendingEmptyState();
      updatePendingCounts();
      setStatus("All pending matches saved.");
    });

    pendingDeleteAll.addEventListener("click", () => {
      if (!pendingCards.size) return;
      pendingCards.clear();
      pendingGrid.innerHTML = "";
      persistPendingCards();
      updatePendingEmptyState();
      updatePendingCounts();
      setStatus("All pending matches deleted.");
    });

    window.addEventListener("load", async () => {
      serverUser = await loadServerUser();
      await syncCollectionFromServer();
      hydrateSavedCards();
      hydratePendingCards();
    });

    window.addEventListener("beforeunload", () => {
      stopCamera();
    });
  </script>
{% endblock %}
